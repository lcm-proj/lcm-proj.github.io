<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LCM: lcm::LCM Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LCM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>lcm</b></li><li class="navelem"><a class="el" href="classlcm_1_1LCM.html">LCM</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classlcm_1_1LCM-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">lcm::LCM Class Reference<div class="ingroups"><a class="el" href="group__LcmCpp.html">C++ API Reference</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Core communications class for the C++ API.  
 <a href="classlcm_1_1LCM.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lcm-cpp_8hpp_source.html">lcm/lcm-cpp.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abc1afb99eee1eb108dd13d0c12b9fc01"><td class="memTemplParams" colspan="2">template&lt;class MessageType &gt; </td></tr>
<tr class="memitem:abc1afb99eee1eb108dd13d0c12b9fc01"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#abc1afb99eee1eb108dd13d0c12b9fc01">HandlerFunction</a> = std::function&lt; void(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel, const MessageType *msg)&gt;</td></tr>
<tr class="separator:abc1afb99eee1eb108dd13d0c12b9fc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a18f8e2693cdafb36c4481789aa8ec24e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a18f8e2693cdafb36c4481789aa8ec24e">LCM</a> (std::string lcm_url=&quot;&quot;)</td></tr>
<tr class="memdesc:a18f8e2693cdafb36c4481789aa8ec24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a18f8e2693cdafb36c4481789aa8ec24e">More...</a><br /></td></tr>
<tr class="separator:a18f8e2693cdafb36c4481789aa8ec24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705349fd49d7321379bd5d0065d6c19a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a705349fd49d7321379bd5d0065d6c19a">LCM</a> (<a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *lcm_in)</td></tr>
<tr class="memdesc:a705349fd49d7321379bd5d0065d6c19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a705349fd49d7321379bd5d0065d6c19a">More...</a><br /></td></tr>
<tr class="separator:a705349fd49d7321379bd5d0065d6c19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d049384b8f55cd281be4f670f84905f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a4d049384b8f55cd281be4f670f84905f">~LCM</a> ()</td></tr>
<tr class="memdesc:a4d049384b8f55cd281be4f670f84905f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a4d049384b8f55cd281be4f670f84905f">More...</a><br /></td></tr>
<tr class="separator:a4d049384b8f55cd281be4f670f84905f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532ecef61ae5651931df3ae7d4cf5a32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a532ecef61ae5651931df3ae7d4cf5a32">good</a> () const</td></tr>
<tr class="memdesc:a532ecef61ae5651931df3ae7d4cf5a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if initialization succeeded during object construction.  <a href="#a532ecef61ae5651931df3ae7d4cf5a32">More...</a><br /></td></tr>
<tr class="separator:a532ecef61ae5651931df3ae7d4cf5a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8596505355407de0f83ea77fbb1deab9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a8596505355407de0f83ea77fbb1deab9">publish</a> (const std::string &amp;channel, const void *data, unsigned int datalen)</td></tr>
<tr class="memdesc:a8596505355407de0f83ea77fbb1deab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes a raw data message.  <a href="#a8596505355407de0f83ea77fbb1deab9">More...</a><br /></td></tr>
<tr class="separator:a8596505355407de0f83ea77fbb1deab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0920e74f7a5176570f1438998282371c"><td class="memTemplParams" colspan="2">template&lt;class MessageType &gt; </td></tr>
<tr class="memitem:a0920e74f7a5176570f1438998282371c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a0920e74f7a5176570f1438998282371c">publish</a> (const std::string &amp;channel, const MessageType *msg)</td></tr>
<tr class="memdesc:a0920e74f7a5176570f1438998282371c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes a message with automatic message encoding.  <a href="#a0920e74f7a5176570f1438998282371c">More...</a><br /></td></tr>
<tr class="separator:a0920e74f7a5176570f1438998282371c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacaf64ce2c73a8a7f3fcde386c112055"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#aacaf64ce2c73a8a7f3fcde386c112055">getFileno</a> ()</td></tr>
<tr class="memdesc:aacaf64ce2c73a8a7f3fcde386c112055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a file descriptor or socket that can be used with <code>select()</code>, <code>poll()</code>, or other event loops for asynchronous notification of incoming messages.  <a href="#aacaf64ce2c73a8a7f3fcde386c112055">More...</a><br /></td></tr>
<tr class="separator:aacaf64ce2c73a8a7f3fcde386c112055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac221c0fa80ede30a2383fba612f972e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e">handle</a> ()</td></tr>
<tr class="memdesc:aac221c0fa80ede30a2383fba612f972e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for and dispatches messages.  <a href="#aac221c0fa80ede30a2383fba612f972e">More...</a><br /></td></tr>
<tr class="separator:aac221c0fa80ede30a2383fba612f972e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab21e812a15afbd92bbfdd091804d9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a8ab21e812a15afbd92bbfdd091804d9b">handleTimeout</a> (int timeout_millis)</td></tr>
<tr class="memdesc:a8ab21e812a15afbd92bbfdd091804d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for and dispatches messages, with a timeout.  <a href="#a8ab21e812a15afbd92bbfdd091804d9b">More...</a><br /></td></tr>
<tr class="separator:a8ab21e812a15afbd92bbfdd091804d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a71519b8fb0f942b385a60b70f87baf"><td class="memTemplParams" colspan="2">template&lt;class MessageType , class MessageHandlerClass &gt; </td></tr>
<tr class="memitem:a1a71519b8fb0f942b385a60b70f87baf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a1a71519b8fb0f942b385a60b70f87baf">subscribe</a> (const std::string &amp;channel, void(MessageHandlerClass::*handlerMethod)(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel, const MessageType *msg), MessageHandlerClass *handler)</td></tr>
<tr class="memdesc:a1a71519b8fb0f942b385a60b70f87baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes a callback method of an object to a channel, with automatic message decoding.  <a href="#a1a71519b8fb0f942b385a60b70f87baf">More...</a><br /></td></tr>
<tr class="separator:a1a71519b8fb0f942b385a60b70f87baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e2b44dca98698720552d3e76aa2e61"><td class="memTemplParams" colspan="2">template&lt;class MessageHandlerClass &gt; </td></tr>
<tr class="memitem:a17e2b44dca98698720552d3e76aa2e61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a17e2b44dca98698720552d3e76aa2e61">subscribe</a> (const std::string &amp;channel, void(MessageHandlerClass::*handlerMethod)(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel), MessageHandlerClass *handler)</td></tr>
<tr class="memdesc:a17e2b44dca98698720552d3e76aa2e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe a callback method of an object to a channel, without automatic message decoding.  <a href="#a17e2b44dca98698720552d3e76aa2e61">More...</a><br /></td></tr>
<tr class="separator:a17e2b44dca98698720552d3e76aa2e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207638f92682307b200e0132a4639430"><td class="memTemplParams" colspan="2">template&lt;class MessageType , class ContextClass &gt; </td></tr>
<tr class="memitem:a207638f92682307b200e0132a4639430"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a207638f92682307b200e0132a4639430">subscribeFunction</a> (const std::string &amp;channel, void(*handler)(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel, const MessageType *msg, ContextClass context), ContextClass context)</td></tr>
<tr class="memdesc:a207638f92682307b200e0132a4639430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe a function callback to a channel, with automatic message decoding.  <a href="#a207638f92682307b200e0132a4639430">More...</a><br /></td></tr>
<tr class="separator:a207638f92682307b200e0132a4639430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18a362fee1eae7e84387eea98c2575f"><td class="memTemplParams" colspan="2">template&lt;class ContextClass &gt; </td></tr>
<tr class="memitem:aa18a362fee1eae7e84387eea98c2575f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#aa18a362fee1eae7e84387eea98c2575f">subscribeFunction</a> (const std::string &amp;channel, void(*handler)(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel, ContextClass context), ContextClass context)</td></tr>
<tr class="memdesc:aa18a362fee1eae7e84387eea98c2575f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe a function callback to a channel, without automatic message decoding.  <a href="#aa18a362fee1eae7e84387eea98c2575f">More...</a><br /></td></tr>
<tr class="separator:aa18a362fee1eae7e84387eea98c2575f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d6d0c4831465186f6b8472a767fb58"><td class="memTemplParams" colspan="2">template&lt;class MessageType &gt; </td></tr>
<tr class="memitem:a46d6d0c4831465186f6b8472a767fb58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a46d6d0c4831465186f6b8472a767fb58">subscribe</a> (const std::string &amp;channel, <a class="el" href="classlcm_1_1LCM.html#abc1afb99eee1eb108dd13d0c12b9fc01">HandlerFunction</a>&lt; MessageType &gt; handler)</td></tr>
<tr class="memdesc:a46d6d0c4831465186f6b8472a767fb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribes a callback function to a channel, with automatic message decoding.  <a href="#a46d6d0c4831465186f6b8472a767fb58">More...</a><br /></td></tr>
<tr class="separator:a46d6d0c4831465186f6b8472a767fb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b48c70992c4d0c36d782208ca4dd93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#ac9b48c70992c4d0c36d782208ca4dd93">unsubscribe</a> (<a class="el" href="classlcm_1_1Subscription.html">Subscription</a> *subscription)</td></tr>
<tr class="memdesc:ac9b48c70992c4d0c36d782208ca4dd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribes a message handler.  <a href="#ac9b48c70992c4d0c36d782208ca4dd93">More...</a><br /></td></tr>
<tr class="separator:ac9b48c70992c4d0c36d782208ca4dd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6221cd1f4c6ed608a1cf8cfb38cafedb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlcm_1_1LCM.html#a6221cd1f4c6ed608a1cf8cfb38cafedb">getUnderlyingLCM</a> ()</td></tr>
<tr class="memdesc:a6221cd1f4c6ed608a1cf8cfb38cafedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrives the lcm_t C data structure wrapped by this class.  <a href="#a6221cd1f4c6ed608a1cf8cfb38cafedb">More...</a><br /></td></tr>
<tr class="separator:a6221cd1f4c6ed608a1cf8cfb38cafedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core communications class for the C++ API. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abc1afb99eee1eb108dd13d0c12b9fc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1afb99eee1eb108dd13d0c12b9fc01">&#9670;&nbsp;</a></span>HandlerFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MessageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlcm_1_1LCM.html#abc1afb99eee1eb108dd13d0c12b9fc01">lcm::LCM::HandlerFunction</a> =  std::function&lt;void(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel, const MessageType *msg)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type alias for the handler function type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a18f8e2693cdafb36c4481789aa8ec24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f8e2693cdafb36c4481789aa8ec24e">&#9670;&nbsp;</a></span>LCM() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lcm::LCM::LCM </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>lcm_url</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Initializes the <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> instance and connects it to the specified <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> network. See the documentation on <a class="el" href="group__LcmC__lcm__t.html#gaf29963ef43edadf45296d5ad82c18d4b" title="Constructor. ">lcm_create()</a> in the C API for details on how lcm_url is formatted.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LcmC__lcm__t.html#gaf29963ef43edadf45296d5ad82c18d4b" title="Constructor. ">lcm_create()</a> </dd></dl>

</div>
</div>
<a id="a705349fd49d7321379bd5d0065d6c19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705349fd49d7321379bd5d0065d6c19a">&#9670;&nbsp;</a></span>LCM() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lcm::LCM::LCM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> *&#160;</td>
          <td class="paramname"><em>lcm_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Initializes the c++ <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> instance from an existing C instance.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LcmC__lcm__t.html#gaf29963ef43edadf45296d5ad82c18d4b" title="Constructor. ">lcm_create()</a> </dd></dl>

</div>
</div>
<a id="a4d049384b8f55cd281be4f670f84905f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d049384b8f55cd281be4f670f84905f">&#9670;&nbsp;</a></span>~LCM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lcm::LCM::~LCM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Disconnects from the <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> network, and destroys all outstanding <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> objects. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aacaf64ce2c73a8a7f3fcde386c112055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaf64ce2c73a8a7f3fcde386c112055">&#9670;&nbsp;</a></span>getFileno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lcm::LCM::getFileno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a file descriptor or socket that can be used with <code>select()</code>, <code>poll()</code>, or other event loops for asynchronous notification of incoming messages. </p>
<p>This method is useful when integrating <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> into another event loop, such as the Qt event loop (via QSocketNotifier), the GLib event loop (via GIOChannel), a custom <code>select()</code> <code>-</code> or <code>poll()</code> <code>-based</code> event loop, or any other event loop that supports file descriptors.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>link to example code.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a non-negative file descriptor on success, or -1 if something is wrong. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LcmC__lcm__t.html#ga51bd65da2efbd1ef094cb36b4a906922" title="Returns a file descriptor or socket that can be used with select(), poll(), or other event loops for ...">lcm_get_fileno()</a> </dd></dl>

</div>
</div>
<a id="a6221cd1f4c6ed608a1cf8cfb38cafedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6221cd1f4c6ed608a1cf8cfb38cafedb">&#9670;&nbsp;</a></span>getUnderlyingLCM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> * lcm::LCM::getUnderlyingLCM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>retrives the lcm_t C data structure wrapped by this class. </p>
<p>This method should be used carefully and sparingly. An example use case would be extending the subscription mechanism to Boost Function objects.</p>
<dl class="section return"><dt>Returns</dt><dd>the lcm_t instance wrapped by this object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LcmC__lcm__t.html#gabb730c9e49442a4bcf400e0f2fef7576">lcm_t</a> </dd></dl>

</div>
</div>
<a id="a532ecef61ae5651931df3ae7d4cf5a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532ecef61ae5651931df3ae7d4cf5a32">&#9670;&nbsp;</a></span>good()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lcm::LCM::good </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if initialization succeeded during object construction. </p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization succeeded and the instance appears ready for communication, false if not. </dd></dl>

</div>
</div>
<a id="aac221c0fa80ede30a2383fba612f972e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac221c0fa80ede30a2383fba612f972e">&#9670;&nbsp;</a></span>handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lcm::LCM::handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for and dispatches messages. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if something went wrong. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LcmC__lcm__t.html#ga964c763e37b3c7f8af9ca37df381b10a" title="Wait for and dispatch the next incoming message. ">lcm_handle()</a> </dd></dl>

</div>
</div>
<a id="a8ab21e812a15afbd92bbfdd091804d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab21e812a15afbd92bbfdd091804d9b">&#9670;&nbsp;</a></span>handleTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lcm::LCM::handleTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_millis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for and dispatches messages, with a timeout. </p>
<p>New in <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> 1.1.0.</p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if a message was handled, 0 if the function timed out, and &lt;0 if an error occured. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__LcmC__lcm__t.html#ga48b225668d5c08264af47c7dd2ffb70f" title="Wait for and dispatch the next incoming message, up to a time limit. ">lcm_handle_timeout()</a> </dd></dl>

</div>
</div>
<a id="a8596505355407de0f83ea77fbb1deab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8596505355407de0f83ea77fbb1deab9">&#9670;&nbsp;</a></span>publish() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lcm::LCM::publish </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>datalen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publishes a raw data message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to publish the message on. </td></tr>
    <tr><td class="paramname">data</td><td>data buffer containing the message to publish </td></tr>
    <tr><td class="paramname">datalen</td><td>length of the message, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a0920e74f7a5176570f1438998282371c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0920e74f7a5176570f1438998282371c">&#9670;&nbsp;</a></span>publish() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MessageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lcm::LCM::publish </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MessageType *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Publishes a message with automatic message encoding. </p>
<p>This template method is designed for use with C++ classes generated by lcm-gen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>the channel to publish the message on. </td></tr>
    <tr><td class="paramname">msg</td><td>the message to publish.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a1a71519b8fb0f942b385a60b70f87baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a71519b8fb0f942b385a60b70f87baf">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MessageType , class MessageHandlerClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> * lcm::LCM::subscribe </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MessageHandlerClass::*)(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel, const MessageType *msg)&#160;</td>
          <td class="paramname"><em>handlerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageHandlerClass *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes a callback method of an object to a channel, with automatic message decoding. </p>
<p>This method is designed for use with C++ classes generated by <code>lcm-gen</code> <code></code>.</p>
<p>The callback method will be invoked on the object when a message arrives on the specified channel. Prior to method invocation, <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> will attempt to automatically decode the message to the specified message type <code>MessageType</code> <code></code>, which should be a class generated by <code>lcm-gen</code> <code></code>. If message decoding fails, the callback method is not invoked and an error message is printed to stderr.</p>
<p>The callback method is invoked during calls to <a class="el" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e" title="Waits for and dispatches messages. ">LCM::handle()</a>. Callback methods are invoked by the same thread that invokes <a class="el" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e" title="Waits for and dispatches messages. ">LCM::handle()</a>, in the order that they were subscribed.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;exlcm/example_t.lcm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;lcm/lcm-cpp.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyMessageHandler {</div><div class="line">  <span class="keywordtype">void</span> onMessage(<span class="keyword">const</span> <a class="code" href="structlcm_1_1ReceiveBuffer.html">lcm::ReceiveBuffer</a>* rbuf, <span class="keyword">const</span> std::string&amp; channel,</div><div class="line">          <span class="keyword">const</span> exlcm::example_t* msg) {</div><div class="line">     <span class="comment">// do something with the message</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  <a class="code" href="classlcm_1_1LCM.html">lcm::LCM</a> <a class="code" href="namespacelcm.html">lcm</a>;</div><div class="line">  MyMessageHandler handler;</div><div class="line">  lcm.<a class="code" href="classlcm_1_1LCM.html#a1a71519b8fb0f942b385a60b70f87baf">subscribe</a>(<span class="stringliteral">&quot;CHANNEL&quot;</span>, &amp;MyMessageHandler::onMessage, &amp;handler);</div><div class="line">  <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div><div class="line">    lcm.<a class="code" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e">handle</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to subscribe to. This is treated as a regular expression implicitly surrounded by '^' and '$'. </td></tr>
    <tr><td class="paramname">handlerMethod</td><td>A class method pointer identifying the callback method. </td></tr>
    <tr><td class="paramname">handler</td><td>A class instance that the callback method will be invoked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object that can be used to adjust the subscription and unsubscribe. The <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object is managed by the <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> class, and is automatically destroyed when its <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> instance is destroyed. </dd></dl>

</div>
</div>
<a id="a17e2b44dca98698720552d3e76aa2e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e2b44dca98698720552d3e76aa2e61">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MessageHandlerClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> * lcm::LCM::subscribe </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MessageHandlerClass::*)(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel)&#160;</td>
          <td class="paramname"><em>handlerMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MessageHandlerClass *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe a callback method of an object to a channel, without automatic message decoding. </p>
<p>This method is designed for use when automatic message decoding is not desired.</p>
<p>The callback method will be invoked on the object when a message arrives on the specified channel. Callback methods are invoked during calls to <a class="el" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e" title="Waits for and dispatches messages. ">LCM::handle()</a>, by the same thread that calls <a class="el" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e" title="Waits for and dispatches messages. ">LCM::handle()</a>. Callbacks are invoked in the order that they were subscribed.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;lcm/lcm-cpp.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyMessageHandler {</div><div class="line">  <span class="keywordtype">void</span> onMessage(<span class="keyword">const</span> <a class="code" href="structlcm_1_1ReceiveBuffer.html">lcm::ReceiveBuffer</a>* rbuf, <span class="keyword">const</span> std::string&amp; channel) {</div><div class="line">     <span class="comment">// do something with the message.  Raw message bytes are</span></div><div class="line">     <span class="comment">// accessible via rbuf-&gt;data</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  <a class="code" href="classlcm_1_1LCM.html">lcm::LCM</a> lcm;</div><div class="line">  MyMessageHandler handler;</div><div class="line">  lcm.<a class="code" href="classlcm_1_1LCM.html#a1a71519b8fb0f942b385a60b70f87baf">subscribe</a>(<span class="stringliteral">&quot;CHANNEL&quot;</span>, &amp;MyMessageHandler::onMessage, &amp;handler);</div><div class="line">  <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div><div class="line">    lcm.<a class="code" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e">handle</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to subscribe to. This is treated as a regular expression implicitly surrounded by '^' and '$'. </td></tr>
    <tr><td class="paramname">handlerMethod</td><td>A class method pointer identifying the callback method. </td></tr>
    <tr><td class="paramname">handler</td><td>A class instance that the callback method will be invoked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object that can be used to adjust the subscription and unsubscribe. The <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object is managed by the <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> class, and is automatically destroyed when its <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> instance is destroyed. </dd></dl>

</div>
</div>
<a id="a46d6d0c4831465186f6b8472a767fb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d6d0c4831465186f6b8472a767fb58">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MessageType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> * lcm::LCM::subscribe </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlcm_1_1LCM.html#abc1afb99eee1eb108dd13d0c12b9fc01">LCM::HandlerFunction</a>&lt; MessageType &gt;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribes a callback function to a channel, with automatic message decoding. </p>
<p>This method is designed for use with C++ classes generated by <code>lcm-gen</code> <code></code>.</p>
<p>The callback function will be invoked on the object when a message arrives on the specified channel. Prior to method invocation, <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> will attempt to automatically decode the message to the specified message type <code>MessageType</code> <code></code>, which should be a class generated by <code>lcm-gen</code> <code></code>. If message decoding fails, the callback function is not invoked and an error message is printed to stderr.</p>
<p>The callback function is invoked during calls to <a class="el" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e" title="Waits for and dispatches messages. ">LCM::handle()</a>. Callback methods are invoked by the same thread that invokes <a class="el" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e" title="Waits for and dispatches messages. ">LCM::handle()</a>, in the order that they were subscribed.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;exlcm/example_t.lcm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;lcm/lcm-cpp.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  <a class="code" href="classlcm_1_1LCM.html">lcm::LCM</a> lcm;</div><div class="line">  <a class="code" href="classlcm_1_1LCM.html#abc1afb99eee1eb108dd13d0c12b9fc01">lcm::LCM::HandlerFunction&lt;exlcm::example_t&gt;</a> func;</div><div class="line">  func = [](<span class="keyword">const</span> <a class="code" href="structlcm_1_1ReceiveBuffer.html">lcm::ReceiveBuffer</a>* rbuf, <span class="keyword">const</span> std::string&amp; channel,</div><div class="line">            <span class="keyword">const</span> exlcm::example_t* msg) {</div><div class="line">      <span class="comment">// do something with the message</span></div><div class="line">  }</div><div class="line">  lcm.<a class="code" href="classlcm_1_1LCM.html#a1a71519b8fb0f942b385a60b70f87baf">subscribe</a>(<span class="stringliteral">&quot;CHANNEL&quot;</span>, func);</div><div class="line">  <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div><div class="line">    lcm.<a class="code" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e">handle</a>();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to subscribe to. This is treated as a regular expression implicitly surrounded by '^' and '$'. </td></tr>
    <tr><td class="paramname">handler</td><td>A handler function, for example a lambda.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object that can be used to adjust the subscription and unsubscribe. The <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object is managed by the <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> class, and is automatically destroyed when its <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> instance is destroyed. </dd></dl>

</div>
</div>
<a id="a207638f92682307b200e0132a4639430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207638f92682307b200e0132a4639430">&#9670;&nbsp;</a></span>subscribeFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MessageType , class ContextClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> * lcm::LCM::subscribeFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel, const MessageType *msg, ContextClass context)&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContextClass&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe a function callback to a channel, with automatic message decoding. </p>
<p>This method is designed for use with static member functions and C-style functions.</p>
<p>The callback function will be invoked on the object when a message arrives on the specified channel. Prior to callback invocation, <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> will attempt to automatically decode the message to the specified message type <code>MessageType</code> <code></code>, which should be a class generated by <code>lcm-gen</code> <code></code>. If message decoding fails, the callback function is not invoked and an error message is printed to stderr.</p>
<p>The callback function is invoked during calls to <a class="el" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e" title="Waits for and dispatches messages. ">LCM::handle()</a>. Callbacks are invoked by the same thread that invokes <a class="el" href="classlcm_1_1LCM.html#aac221c0fa80ede30a2383fba612f972e" title="Waits for and dispatches messages. ">LCM::handle()</a>, in the order that they were subscribed.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;lcm/lcm-cpp.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>State {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="classlcm_1_1LCM.html">lcm::LCM</a> lcm;</div><div class="line">  <span class="keywordtype">int</span> usefulVariable;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> onMessage(<span class="keyword">const</span> <a class="code" href="structlcm_1_1ReceiveBuffer.html">lcm::ReceiveBuffer</a>* rbuf, <span class="keyword">const</span> std::string&amp; channel, <span class="keyword">const</span> MessageType*</div><div class="line">msg, State* state) {</div><div class="line">  <span class="comment">// do something with the message.</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  State* state = <span class="keyword">new</span> State;</div><div class="line">  state-&gt;lcm.subscribe(<span class="stringliteral">&quot;CHANNEL&quot;</span>, onMessage, state);</div><div class="line">  <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div><div class="line">    state-&gt;lcm.handle();</div><div class="line">  <span class="keyword">delete</span> state;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to subscribe to. This is treated as a regular expression implicitly surrounded by '^' and '$'. </td></tr>
    <tr><td class="paramname">handler</td><td>A function pointer identifying the callback function. </td></tr>
    <tr><td class="paramname">context</td><td>A context variable that will be passed to the callback function. This can be used to pass state or other information to the callback function. If not needed, then <code>ContextClass</code> <code>can</code> be set to void*, and this argument set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object that can be used to adjust the subscription and unsubscribe. The <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object is managed by the <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> class, and is automatically destroyed when its <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> instance is destroyed. </dd></dl>

</div>
</div>
<a id="aa18a362fee1eae7e84387eea98c2575f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18a362fee1eae7e84387eea98c2575f">&#9670;&nbsp;</a></span>subscribeFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ContextClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> * lcm::LCM::subscribeFunction </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const <a class="el" href="structlcm_1_1ReceiveBuffer.html">ReceiveBuffer</a> *rbuf, const std::string &amp;channel, ContextClass context)&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContextClass&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscribe a function callback to a channel, without automatic message decoding. </p>
<p>This method is designed for use when automatic message decoding is not desired.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;lcm/lcm-cpp.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> onMessage(<span class="keyword">const</span> <a class="code" href="structlcm_1_1ReceiveBuffer.html">lcm::ReceiveBuffer</a>* rbuf, <span class="keyword">const</span> std::string&amp; channel, <span class="keywordtype">void</span>*) {</div><div class="line">  <span class="comment">// do something with the message.  Raw message bytes are</span></div><div class="line">  <span class="comment">// accessible via rbuf-&gt;data</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line">  LCM::lcm lcm;</div><div class="line">  lcm.<a class="code" href="classlcm_1_1LCM.html#a1a71519b8fb0f942b385a60b70f87baf">subscribe</a>(<span class="stringliteral">&quot;CHANNEL&quot;</span>, onMessage, NULL);</div><div class="line">  <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div><div class="line">    lcm.handle();</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel to subscribe to. This is treated as a regular expression implicitly surrounded by '^' and '$'. </td></tr>
    <tr><td class="paramname">handler</td><td>A function pointer identifying the callback function. </td></tr>
    <tr><td class="paramname">context</td><td>A context variable that will be passed to the callback function. This can be used to pass state or other information to the callback function. If not needed, then <code>ContextClass</code> <code>can</code> be set to void*, and this argument set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object that can be used to adjust the subscription and unsubscribe. The <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object is managed by the <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> class, and is automatically destroyed when its <a class="el" href="classlcm_1_1LCM.html" title="Core communications class for the C++ API. ">LCM</a> instance is destroyed. </dd></dl>

</div>
</div>
<a id="ac9b48c70992c4d0c36d782208ca4dd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b48c70992c4d0c36d782208ca4dd93">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lcm::LCM::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlcm_1_1Subscription.html">Subscription</a> *&#160;</td>
          <td class="paramname"><em>subscription</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsubscribes a message handler. </p>
<p>After unsubscription, the callback registered by the original call to <a class="el" href="classlcm_1_1LCM.html#a1a71519b8fb0f942b385a60b70f87baf" title="Subscribes a callback method of an object to a channel, with automatic message decoding. ">subscribe()</a> or <a class="el" href="classlcm_1_1LCM.html#a207638f92682307b200e0132a4639430" title="Subscribe a function callback to a channel, with automatic message decoding. ">subscribeFunction()</a> will no longer be invoked when messages are received. The <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object is destroyed by this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subscription</td><td>a <a class="el" href="classlcm_1_1Subscription.html" title="Represents a channel subscription, and can be used to unsubscribe and set options. ">Subscription</a> object previously returned by a call to <a class="el" href="classlcm_1_1LCM.html#a1a71519b8fb0f942b385a60b70f87baf" title="Subscribes a callback method of an object to a channel, with automatic message decoding. ">subscribe()</a> or <a class="el" href="classlcm_1_1LCM.html#a207638f92682307b200e0132a4639430" title="Subscribe a function callback to a channel, with automatic message decoding. ">subscribeFunction()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if <code>subscription</code> is not a valid subscription. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="lcm-cpp_8hpp_source.html">lcm-cpp.hpp</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/></body>
</html>
