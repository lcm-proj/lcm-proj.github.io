<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LCM: LCM Type Specification Language</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LCM
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">LCM Type Specification Language </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The usage and features of the LCM type language.</p>
<h1><a class="anchor" id="type_specification_intro"></a>
Introduction</h1>
<p>In addition to providing a set of communications primitives, LCM includes utilities for generating platform-independent marshalling and unmarshalling functions for user-defined data types. It is similar to XDR, though it is written with greater type safety in mind, and with the goal of first-class support for a variety of languages including C, Java, and Python. This document describes the data marshalling facility; the communications facility is described elsewhere. Note that it is possible to use the data marshalling features of LCM independently of LCM's communication facilities.</p>
<h2><a class="anchor" id="type_specification_design_goals"></a>
Design Goals</h2>
<p>The primary design goals of the LCM marshalling facility are:</p>
<ul>
<li>Provide a simple mechanism to define complex types that would be immediately comfortable to users of C and Java </li>
<li>Provide first class support for a wide variety of client languages </li>
<li>Abstract away platform-specific details such as byte ordering </li>
<li>Maximize the amount of compile-time and run-time type safety </li>
<li>Be able to detect message type incompatibilities, such as when two applications have different versions of the same datatype </li>
<li>Produce space-efficient encoded messages </li>
<li>Minimize encoding and decoding computational costs</li>
</ul>
<p>The current version of LCM achieves these goals with only a few compromises. In some cases, a least-common-denominator approach was used to ensure that all platforms supported the features provided by LCM.</p>
<h1><a class="anchor" id="type_specification_spec"></a>
Type Specifications</h1>
<p>Type specifications are contained in files with an ".lcm" file type. They are conventionally named in lower case with underscores between words: e.g., the type "wind_speed_t" is defined in the file "wind_speed_t.lcm". The utility <code>lcm-gen</code> converts an LCM type specification into a language-dependent implementation.</p>
<h2><a class="anchor" id="type_specification_structs"></a>
Structs</h2>
<p>LCM structs are compound types consisting of other types. We begin with a simple struct named "temperature_t" that contains a 64 bit integer named "utime" and a 64 bit floating point number named "degCelsius". Two types of comments are also illustrated.</p>
<div class="fragment"><div class="line">struct temperature_t </div><div class="line">{</div><div class="line">    int64_t   utime;         // Timestamp, in microseconds</div><div class="line"></div><div class="line">    /* Temperature in degrees Celsius. A &quot;float&quot; would probably</div><div class="line">     * be good enough, unless we&#39;re measuring temperatures during</div><div class="line">     * the big bang. Note that the asterisk on the beginning of this</div><div class="line">     * line is not syntactically necessary, it&#39;s just pretty.</div><div class="line">     */</div><div class="line">    double    degCelsius;    </div><div class="line">}</div></div><!-- fragment --><p>This declaration must appear in a file named <code>temperature_t.lcm</code>.</p>
<p>LCM types do not contain pointers (but arrays are supported, see below): this eliminates the possibility of circular references.</p>
<p>Before we go further, let's take a look at the various primitive types available.</p>
<h3><a class="anchor" id="type_specification_primitives"></a>
Primitive Types</h3>
<p>LCM supports a number of primitive types: </p><table class="doxtable">
<tr>
<th>type</th><th>Description </th></tr>
<tr>
<td><code>int8_t</code></td><td>8-bit signed integer </td></tr>
<tr>
<td><code>int16_t</code></td><td>16-bit signed integer </td></tr>
<tr>
<td><code>int32_t</code></td><td>32-bit signed integer </td></tr>
<tr>
<td><code>int64_t</code></td><td>64-bit signed integer </td></tr>
<tr>
<td><code>float</code></td><td>32-bit IEEE floating point value </td></tr>
<tr>
<td><code>double</code></td><td>64-bit IEEE floating point value </td></tr>
<tr>
<td><code>string</code></td><td>UTF-8 string </td></tr>
<tr>
<td><code>boolean</code></td><td>true/false logical value </td></tr>
<tr>
<td><code>byte</code></td><td>8-bit value </td></tr>
</table>
<p>The integer types are all signed (as is necessary to ensure easy inter-operation with Java, which lacks unsigned types) and are encoded in network byte order.</p>
<p>The type <code>byte</code> is represented in C/C++ as <code>uint8_t</code>. Languages with a native <code>byte</code> representation use their respective native byte representations (e.g., type <code>byte</code> in Java).</p>
<p>Floating point types are encoded using the IEEE 32 and 64 bit formats. An LCM implementation may not use any other encoding. The 32 and 64 bit quantities are transmitted in network byte order.</p>
<p>The <code>boolean</code> type is encoded as a single byte whose value is either 0 or 1. An array of N booleans will require N bytes.</p>
<p>The <code>string</code> type encodes a NULL-terminated UTF-8 string. The string is sent as a 32 bit integer comprising the total length of string in bytes (including terminating NULL character) followed by the bytes of the string (again, including the NULL character).</p>
<h3><a class="anchor" id="type_specification_arrays"></a>
Arrays</h3>
<p>LCM supports multi-dimensional arrays consisting of primitives, structs, or constant declarations. The number of dimensions in the array are declared by the LCM type declaration: you cannot encode an LCM type that consists of a variable-dimension array. In contrast, variable-sized arrays are fine. Consider this example:</p>
<div class="fragment"><div class="line">struct point2d_list_t</div><div class="line">{</div><div class="line">    int32_t npoints;</div><div class="line">    double  points[npoints][2];</div><div class="line">}</div></div><!-- fragment --><p>This example shows a two-dimensional array declaration consisting of both variable-length and fixed-length components. In a variable-length declaration, the variable that contains the length must be declared prior to its use as an array length. Also note that the length variable (npoints, in the example above) must be an integer type, and must always have a value greater than or equal to zero.</p>
<p>When arrays are encoded and decoded, each dimension's size is already known: it is either a constant (given by the LCM type declaration), or it was a previously encoded/decoded variable. Thus, an array is encoded simply by recursively encoding each element of the array, with inner-most dimensions being encoded together. In other words, the array above would be encoded in the order <code> points[0][0], points[0][1], points[1][0], points[1][1], points[2][0], points[2][1],</code> etc.</p>
<h2><a class="anchor" id="type_specification_constants"></a>
Constants</h2>
<p>LCM provides a simple way of declaring constants that can subsequently be used to populate other data fields. Users are free to use these constants in any way they choose: as magic numbers, enumerations, or bitfields.</p>
<p>Constants can be declared by using the const keyword.</p>
<div class="fragment"><div class="line">struct my_constants_t</div><div class="line">{</div><div class="line">    const int32_t YELLOW=1, GOLDENROD=2, CANARY=3;</div><div class="line">    const double E=2.8718;</div><div class="line">}</div></div><!-- fragment --><p>Note that types must be declared for constants. All integer and floating point types are supported. String constants are not supported.</p>
<h1><a class="anchor" id="type_specification_namespaces"></a>
Namespaces</h1>
<p>LCM allows types to be defined in a namespace, making it easier for users to use types from other organizations even if those types have the same name. The namespace mechanism is closely modeled after that of Java. In languages that support namespaces (such as Java and Python), the LCM namespace mechanism is mapped onto the native mechanism. In languages like C, namespaces are approximated by prepending the package name to the type name. See below for an example of namespaces. Note that the package keyword identifies the namespace of the structs defined in that file, and that fully-qualified types are formed by concatenating the package and type name, with a period between.</p>
<div class="fragment"><div class="line">package mycorp;</div><div class="line"></div><div class="line">struct camera_image_t {</div><div class="line">    int64_t      utime;</div><div class="line">    string       camera_name;</div><div class="line">    jpeg.image_t jpeg_image;</div><div class="line">    mit.pose_t   pose;</div><div class="line">}</div></div><!-- fragment --><p>LCM users are encouraged to put their types into a unique namespace and to fully-qualify the types of all the member fields.</p>
<h1><a class="anchor" id="type_specification_performance"></a>
Performance Considerations</h1>
<p>The runtime costs of encoding and decoding with LCM are generally not a system bottleneck. The marshalling functions are dramatically faster than an XML implementation, but since each member must be individually processed (in order to ensure correct byte ordering, for example), LCM is more expensive than using raw C structs. That said, LCM's first application used over 40MB/s.</p>
<h1><a class="anchor" id="type_specification_fingerprints"></a>
Fingerprint Computation</h1>
<p>Fingerprints ensure that the encoding and decoding methods agree on the format of a data type. The fingerprints are a function, recursively, of all of the types that a type contains. This creates a potential problem when types could be mutually recursive: we must avoid an infinite recursion.</p>
<p>The basic idea is for each type to have a "base" fingerprint, which we'll denote for type "A" as "K_A". K_A is a constant derived from the lcm type description (and it's stored as lcm_struct-&gt;hash). We wish to compute the actual fingerprint (or hash), A(), which is a function of all of A's contained types.</p>
<p>In addition, so that we can recognize a recursion, the A() function takes an argument, which is a list of the types already visited. E.g., C([A,B]) indicates that we wish to compute the hash of type C, given that C is a member of type B, which is a member of type A. We avoid recursions by setting C([list]) = 0 if [list] contains C.</p>
<p>The contribution of primitive types is handled via the K_A; there is no recursion for them.</p>
<p>A small wrinkle arises from the above definitions: if types A, B, and C are mutually recursive, we can have two types with the same hash. This is clearly undesirable. We fix this by making the order of recursion relevant: at each node in the tree, we rotate the value (bitwise) 1 bit to the left. A type that is included at recursion depth N has its contribution rotated by N bits.</p>
<p>Note that this mechanism is entirely unnecessary for enumerations (they cannot contain other types); for enumerations, we just use the hash in lcmenum-&gt;hash.</p>
<p>PSEUDO-CODE</p>
<div class="fragment"><div class="line">v = compute_hash(type, parents)</div><div class="line"></div><div class="line">if type is member of parents</div><div class="line">   return 0</div><div class="line"></div><div class="line">v = K_type;</div><div class="line"></div><div class="line">for each members m of type</div><div class="line">    v += compute_hash(m, [parents, type])</div><div class="line"></div><div class="line">return rot_left(v);</div></div><!-- fragment --><p>When encoding/decode a type T, we would use compute_hash(T, []) as the hash function.</p>
<p>EXAMPLE</p>
<div class="fragment"><div class="line">struct A</div><div class="line">{</div><div class="line">        B b;</div><div class="line">        C c;</div><div class="line">}</div><div class="line"></div><div class="line">struct B</div><div class="line">{</div><div class="line">        A a;</div><div class="line">}</div><div class="line"></div><div class="line">struct C</div><div class="line">{</div><div class="line">        B b;</div><div class="line">}</div></div><!-- fragment --><p>Diagrammatically, we can compute their hashes by showing the children of each branch. We use lower case to indicate a terminal leaf (where the leaf is the same class as one of its parents).</p>
<pre class="fragment">         A                B                  C
       /   \              |                  |
      B     C             A                  B
      |     |            / \                 |
      a     B           b   C                A
            |               |               / \
            a               b              b   c

A() = R{K_A + R{K_B}} + R{K_C + R{K_B}}}

B() = R{K_B + R{K_A + R{K_C}}}

C() = R{K_C + R{K_B + R{K_A}}}
</pre><p>Note that without the rotations, B() == C().</p>
<h2>Implementation</h2>
<p>For computing the fingerprint, the algorithm is simply:</p>
<ul>
<li>Compute the <b>base hash</b> for the struct<ul>
<li>Includes the fieldname in the base hash.</li>
<li>If the type is a primitive, include its typename in the base hash computation.</li>
<li>If the type is <em>not</em> a primitive, do not include in the base hash computation (as noted above). It will be included in the recursive computation.</li>
</ul>
</li>
<li>Recursively compute the <b>fingerprint</b> for the struct.<ul>
<li>This will recurse into non-primitive struct types, using their <b>base hash</b>.</li>
</ul>
</li>
</ul>
<p>The following are pinned reference implementations for C on the parsing side, generating local struct hashes (non-recursive) as well as for the C binding type (where computation is then done recursively):</p>
<ul>
<li><a href="https://github.com/lcm-proj/lcm/blob/v1.4.0/lcmgen/lcmgen.c#L233-L267">https://github.com/lcm-proj/lcm/blob/v1.4.0/lcmgen/lcmgen.c#L233-L267</a></li>
<li><a href="https://github.com/hoxovic/lcm/blob/v1.4.0/lcmgen/emit_c.c#L390-L439">https://github.com/hoxovic/lcm/blob/v1.4.0/lcmgen/emit_c.c#L390-L439</a></li>
</ul>
<p>Of course, this should reflect implementations for other languages.</p>
<h2><a class="anchor" id="type_specification_related_work"></a>
Related Work</h2>
<p>LCM is most similar to XDR, which is used in RPC and is described by RFC4506. Both use a C-like syntax (and even C keywords like "struct"). LCM differs in that its language is smaller: rarely-used features like unions are not supported. LCM does not support pointers: this eliminates the pointer-chasing problems that can arise in XDR. Variable-length arrays are supported in a more natural way in LCM, and LCM includes a type "signature" in the encoded data. This type signature allows run-time error detection.</p>
<p>Data encoding representations are often compared to XML. XML and LCM serve very different functions. The verbosity and generic structure of XML are aids for agents to use information that they understand while safely skipping over properties that are alien to them. In contrast, LCM is designed for agents that are tightly coupled but that may not be in the same memory space. A more rigid type definition, along with space-efficient and computationally-efficient encodings, are better fits for these types of applications.</p>
<h2><a class="anchor" id="type_specification_history"></a>
Development History</h2>
<p>LCM's marshalling facilities were created for use on MIT's DARPA Urban Challenge vehicle, with development starting during the summer of 2006. Early versions supported many features that have since been deprecated: reducing the number of extraneous features has simplified the code base significantly, since most features typically impact several language back-ends (currently C, Java, and Python). </p>
</div></div><!-- contents -->
<hr class="footer"/></body>
</html>
